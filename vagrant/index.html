<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>Vagrant Utils - UD</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/base.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="..">UD</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="..">Welcome</a>
                </li>
            
            
            
                <li >
                    <a href="../git/">Git Utils</a>
                </li>
            
            
            
                <li >
                    <a href="../grunt/">Grunt Utils</a>
                </li>
            
            
            
                <li >
                    <a href="../mongodb/">Mongo DB Utils</a>
                </li>
            
            
            
                <li >
                    <a href="../python/">Python Utils</a>
                </li>
            
            
            
                <li >
                    <a href="../laravel/">Laravel Utils</a>
                </li>
            
            
            
                <li class="active">
                    <a href="./">Vagrant Utils</a>
                </li>
            
            
            
                <li >
                    <a href="../ethmining/">Eth Mining</a>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li >
                    <a rel="next" href="../laravel/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../ethmining/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#vagrant-utils">Vagrant Utils</a></li>
        
            <li><a href="#concepts">Concepts</a></li>
        
    
        <li class="main "><a href="#vagrantfile">Vagrantfile</a></li>
        
            <li><a href="#initial-useful-commands">Initial useful commands</a></li>
        
    
        <li class="main "><a href="#provisioning">Provisioning</a></li>
        
            <li><a href="#with-shell">With shell</a></li>
        
            <li><a href="#with-ansible">With Ansible</a></li>
        
            <li><a href="#playbook">Playbook</a></li>
        
            <li><a href="#templates-and-files">Templates and files</a></li>
        
            <li><a href="#file-module">File module</a></li>
        
            <li><a href="#handlers">Handlers</a></li>
        
    
        <li class="main "><a href="#roles">Roles</a></li>
        
            <li><a href="#main-task-file">Main task file</a></li>
        
            <li><a href="#pre-post-tasks">Pre &amp; Post tasks</a></li>
        
    
        <li class="main "><a href="#run-custom-bash-script-on-vagrant-up-command">Run custom bash script on vagrant up command</a></li>
        
    
        <li class="main "><a href="#port-forwarding">Port forwarding</a></li>
        
    
        <li class="main "><a href="#more-utils">More utils</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="vagrant-utils">Vagrant Utils</h1>
<p>I've find in Vagrant one of the best dev team's tool.</p>
<p>In this repository</p>
<pre><code>- https://github.com/andreafspeziale/vagrant_test
</code></pre>
<p>you can find my experiments with Vagrant + Ansible.</p>
<p>Each branch represents a specific development environment.</p>
<p>To start using Vagrant go to</p>
<pre><code>- http://www.vagrantup.com/downloads
</code></pre>
<p>and download the installation file according to your OS and then follow the simple wizard to getting started</p>
<h2 id="concepts">Concepts</h2>
<pre><code>- Box: it's a package, a representation of the virtual machine on which has been installed a specific OS for a
  Provider

- Provider: it's a block of code that create and manage the virtual machine. It's the one who serve the VM, usually
  virtual box

- Provisioner: don't be confused by Provider, Provisioner it's the one who runs tasks using the VM served by the
  Provider.
  Provisioner is used to configuring the virtual server and installing the packages for your application. The most famous are Puppet, Chef e Ansible.
</code></pre>
<h1 id="vagrantfile">Vagrantfile</h1>
<pre><code>- Reference http://docs.vagrantup.com/v2/vagrantfile/index.html
</code></pre>
<p>The basic configuration is contained in this file and is generated in the root of your project executing the command:</p>
<pre><code>- vagrant init
</code></pre>
<p>In this file you can choose:</p>
<pre><code>- box used as a basis (and where download it), a package with an operating system running on your virtual machine
  config.vm.box = "precise64"
  config.vm.box_url = "http://files.vagrantup.com/precise64.box"

- port forwarding configuration
  config.vm.network "forwarded_port", guest: 80, host: 8080

- provider setup
  config.vm.provider "virtualbox" do |vb|
</code></pre>
<h3 id="initial-useful-commands">Initial useful commands</h3>
<pre><code>- vagrant Up: execute the commands of the vagrant file from next boot which will download and install the Box
  executing all the tasks

- vagrant ssh: with this command you will be able to connect to your VM via ssh
</code></pre>
<h1 id="provisioning">Provisioning</h1>
<h2 id="with-shell">With shell</h2>
<p>The shell provisioner allows you to execute a shell script inside the vagrant box, as root.
You can find an example in my repo</p>
<pre><code>- https://github.com/andreafspeziale/vagrant_test (master)
</code></pre>
<p>Be sure to use in the vagrant file the shell as provisioner</p>
<pre><code>- config.vm.provision :shell, :path =&gt; "test.sh"
</code></pre>
<p>then try to run.</p>
<pre><code>- vagrant up
</code></pre>
<p>As you will see, the script will successfully executed in the end.</p>
<p>If your vagrant is already up, you can run a</p>
<pre><code>- vagrant reload
</code></pre>
<p>to "restart" it or a</p>
<pre><code>- vagrant provision
</code></pre>
<p>if you only want to re-run the provisioners tasks.</p>
<p>For turning the machine off, run</p>
<pre><code>- vagrant halt
</code></pre>
<p>or if you want to start from scratch</p>
<pre><code>- vagrant destroy
</code></pre>
<p>this will destroy any changes made to the base box.</p>
<h2 id="with-ansible">With Ansible</h2>
<p>Why? Because Ansible is just SSH.</p>
<p>Chef and Puppet both have dependencies that must be installed on the server before you can use them, Ansible does not. It runs on your machine and uses SSH to connect to the servers and run the required commands.</p>
<pre><code>config.vm.provision :ansible do |ansible|
    ansible.playbook = "playbook.yml"
end
</code></pre>
<p>Ansible works by running a series of Tasks on your server.
Think of a Task as a single Bash command. You then have what is called a Playbook</p>
<h2 id="playbook">Playbook</h2>
<p>A Playbook tells Ansible what Tasks you want to run on your server. Each Task is run using an Anisble Module. A Module is a built-in way to do something, like access Yum, create a user and so on. That will become clearer later.</p>
<p>Your Playbook should be a YAML list. The list should contain a list of hosts (servers) you want your Playbook to run on, as a single Playbook can control multiple hosts, and then a list of Tasks you want to run on that host.</p>
<p>We're using Vagrant and only have one host for now, so we can just set the value to all, which is a magic value that says: "run these tasks on all servers you know about". Then we tell Ansible that these tasks will require sudo and finally add our tasks: key to begin specifying our Task list.</p>
<h2 id="templates-and-files">Templates and files</h2>
<p>You will probably want to include related tasks in your new include files.
As an example, we'll update your Apache DocumentRoot setting to point at /vagrant rather than /vat/www/html, so you can serve your local files.</p>
<p>The simplest wat is to include your Virtual Host as part of your Ansible Playbook, either in the form of a Template or a File.</p>
<p>In order to create our Virtual Host, we need to follow these four steps:</p>
<pre><code>- Copy the new Virtual Host (with the DocumentRoot set to /vagrant) to /etc/apache2/sites-available

- Disable the 000-Default Virtual Host

- Enable our new Virtual Host

- Reload Apache config.
</code></pre>
<p>So we have:</p>
<pre><code>- created a templates folder

- created a file called virtual-hosts.conf.j2 in which we paste basic virtual host syntax with a DocumentRoot as a
  variable jinja2
</code></pre>
<p>because of the way Apache works, you need to add a new config section for the /vagrant directory, otherwise you'll get 403 Forbidden errors.</p>
<p>Now that we saved the file, open up tasks/apache.yml, we'll need to add a new Task to copy this Template to the server.</p>
<p>You don't need to include the templates directory in the src value, Ansible always assumes Templates will be in a templates directory, relative to the current context (which is important for when we look at Roles later).
If it can't find the file in the templates directory, it will check again in the root before giving up.</p>
<p>The final thing we need to do to copy our template across is to tell Ansible what to use for the value of document_root when it's copying the Template in to place.
Again, there are a few ways to do this, but the simplest is to add a vars: key to your playbook.yml.</p>
<p>The vars: key can live in any position, but convention dictates it comes somewhere before tasks: in your Playbook.  </p>
<p>Test it simply:</p>
<pre><code>- vagrant provision

- cd /etc/apache2/sites-available and you will find out vagrant configuration
</code></pre>
<h2 id="file-module">File module</h2>
<p>Ubuntu's configuration convention for Apache Virtual Hosts is to put the contents of all possible Virtual Hosts in /etc/apache2/sites-available and then use the a2ensite and a2dissite to create and remove symlinks for each active Virutal Host in the /etc/apache2/sites-enabled directory.</p>
<p>We need to add two tasks to our tasks/apache.yml file, one to remove the existing symlink, and one to create our new one</p>
<h2 id="handlers">Handlers</h2>
<p>Telling a service to restart or reload itself manually after every configuration change can be a real pain. Fortunately, Ansible has a way of automating that process for you, and that's by using Handlers.</p>
<p>Handlers are a list of Tasks with a name assigned that you can call by name after another Task has run. They won't run unless another Task triggers them.</p>
<p>Now we tell Ansible to run this new Handler whenever we change the apache config.
To do this we add a list of Handlers to notify when a Task is complete</p>
<h1 id="roles">Roles</h1>
<p>What happens if we want to write a generic Playbook or set of Tasks and then re-use them?</p>
<p>What happens when we want configure more than just a couple of modules?</p>
<p>Our playbook.yml is going to become full of unrelated Handlers and variables and will get difficult to maintain.</p>
<p>Ansible can solve this problem with Roles. A Role is a group of Tasks, Handlers, Variables, Templates, Files, and so on all related to a single purpose.
You could create specific "apache", "MySQL", and "PHP" Roles, or a generic high-level "webserver" Role. It doesn't matter.</p>
<p>We'll try to create two specific roles:</p>
<pre><code>- A Webserver Role (apache + PHP)
- A Database Role (MySQL)
</code></pre>
<h2 id="main-task-file">Main task file</h2>
<p>You'll notice that with our list of Roles we're just specifying the name of the Role, which is just the name of the directory that contains the Role.
Ansible doesn't know which Tasks to run inside that Role though, as a Role can contain multiple Task files.
The secret here is that Ansible will always look for a Task file called main.yml inside the tasks directory of a Role.</p>
<h2 id="pre-post-tasks">Pre &amp; Post tasks</h2>
<p>Before we try this out, there's one more thing we need to do.
Ansible runs your Roles before your Tasks, so our packages will be installed before we've updated the apt cache.
To fix this, we need to rename our 'tasks': key in playbook.yml to 'pre_tasks'.</p>
<h1 id="run-custom-bash-script-on-vagrant-up-command">Run custom bash script on vagrant up command</h1>
<p>Yes it's possible adding additional code.
An example is provided in the vagrant file!</p>
<h1 id="port-forwarding">Port forwarding</h1>
<p>Vagrant forwarded ports allow you to access a port on your host machine and have all data forwarded to a port on the guest machine, over either TCP or UDP.</p>
<p>For example: If the guest machine is running a web server listening on port 80, you can make a forwarded port mapping to port 8080 (or anything) on your host machine. You can then open your browser to localhost:8080 and browse the website, while all actual network data is being sent to the guest.</p>
<h1 id="more-utils">More utils</h1>
<pre><code>- https://github.com/smdahlen/vagrant-hostmanager
</code></pre>
<p>vagrant-hostmanager is a Vagrant 1.1+ plugin that manages the /etc/hosts file on guest machines (and optionally the host). Its goal is to enable resolution of multi-machine environments deployed with a cloud provider where IP addresses are not known in advance.</p>
<p>Manage your vagrant machines in one place with GUI.</p>
<pre><code>- http://vagrantmanager.com/
</code></pre>
<p>Features:</p>
<pre><code>- Indicators for running/halted VM's
- Execute vagrant commands
- Detailed &amp; Customizable
- Multi-Machine Support
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/base.js"></script>
    </body>
</html>